<script type="module">
  /* =========================
   *  Whoâ€™s up next? â€” Realtime
   * ========================= */

  // ----- ENV -----
  const ENV = {
    SUPABASE_URL:
      window.SUPABASE_URL ||
      "https://cdwyqogwbepscrgnopbw.supabase.co",
    SUPABASE_ANON_KEY:
      window.SUPABASE_ANON_KEY ||
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNkd3lxb2d3YmVwc2NyZ25vcGJ3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTk0Njc2MTksImV4cCI6MjA3NTA0MzYxOX0.BhXTYwEoItlHvVoJ0kUB74kFFAWpwt0BZLRkbD96BBQ",
    BASE_URL: window.BASE_URL || window.location.origin,
  };

  // ----- Imports -----
  import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm";

  // ----- Helpers / constants -----
  const $ = (id) => document.getElementById(id);
  const AVATAR_EMOJI = {
    ninja: "ðŸ¥·",
    robot: "ðŸ¤–",
    demon: "ðŸ˜ˆ",
    angel: "ðŸ˜‡",
    alien: "ðŸ‘½",
    pirate: "ðŸ´â€â˜ ï¸",
    wizard: "ðŸ§™â€â™‚ï¸",
    spaceman: "ðŸ§‘â€ðŸš€",
  };
  const LS = "djwheel_rt_v3";
  function getSessionIdFromPath() {
    const m = location.pathname.match(/\/s\/([0-9a-fA-F-]+)/);
    return m ? m[1] : null;
  }
  function formatMMSS(ms) {
    const m = Math.floor(ms / 60000);
    const s = Math.floor((ms % 60000) / 1000);
    return `${String(m).padStart(2, "0")}:${String(s).padStart(2, "0")}`;
  }
  function toast(msg) {
    const t = document.createElement("div");
    t.style.cssText =
      "position:fixed;bottom:14px;left:50%;transform:translateX(-50%);background:#0b1224;color:#e2e8f0;padding:10px 14px;border-radius:8px;border:1px solid #1f2a44;box-shadow:0 8px 20px rgba(0,0,0,.35);z-index:99999";
    t.textContent = msg;
    document.body.appendChild(t);
    setTimeout(() => t.remove(), 1600);
  }

  // ----- Local profile -----
  let me =
    JSON.parse(localStorage.getItem(LS) || "null") || {
      id: crypto.randomUUID(),
      name: "",
      avatar: "ninja",
      color: "#7c3aed",
    };
  function saveMe() {
    localStorage.setItem(LS, JSON.stringify(me));
  }

  // ----- Shared state (synced) -----
  // minutes_per_track default = 6 (host can change)
  let state = {
    host_id: null,
    participants: [],
    active_index: 0,
    tracks_per_turn: 1,
    minutes_per_track: 6,
    tracks_this_turn: 0,
    timer_ms: 0,
    phase: "idle",
  };

  // Derived helpers
  const msPerTrack = () => state.minutes_per_track * 60 * 1000;
  const totalBudgetMs = () => msPerTrack() * state.tracks_per_turn;
  const amHost = () => state.host_id && me.id === state.host_id;

  // ----- UI refs -----
  const wheelEl = $("wheel"),
    namesLayer = $("namesLayer"),
    nextNameEl = $("nextName"),
    turnInfoEl = $("turnInfo"),
    timerEl = $("timer"),
    pointerRing = $("pointerRing"),
    progressLayer = $("progressLayer"),
    sweepHand = $("sweepHand"),
    participantsList = $("participantsList"),
    stillBtn = $("stillBtn"),
    minutesSel = $("minutesPerTrack"),
    tracksSel = $("tracksPerTurn");

  function setStillBtnLabel() {
    if (stillBtn) stillBtn.textContent = `Still Mixing (+${state.minutes_per_track}m)`;
  }

  // ----- Supabase Realtime -----
  const supabase = createClient(ENV.SUPABASE_URL, ENV.SUPABASE_ANON_KEY, {
    auth: { persistSession: true },
  });
  let channel = null;
  let sessionId = getSessionIdFromPath();
  let isSubscribed = false;
  let currentRoom = null;

  function broadcast(event, payload) {
    if (channel && currentRoom === sessionId)
      channel.send({ type: "broadcast", event, payload });
  }

  // ----- Rendering -----
  function rotatePointerToSlice(deg) {
    if (pointerRing) pointerRing.style.transform = `rotate(${deg}deg)`;
  }

  function renderParticipants() {
    participantsList.innerHTML = "";
    state.participants.forEach((p, i) => {
      const row = document.createElement("div");
      row.className = "item";
      row.innerHTML = `
        <div>${AVATAR_EMOJI[p.avatar] || "ðŸŽ§"} ${p.name}
          <span style="display:inline-block;width:14px;height:14px;border-radius:50%;border:1px solid #1f2a44;background:${p.color};margin-left:6px;"></span>
          <small class="muted"> (pos ${i + 1}) ${p.id === state.host_id ? " â€¢ Host" : ""}</small>
        </div>
        <div class="row">
          ${
            amHost()
              ? `
            <button class="secondary" data-up="${p.id}">â†‘</button>
            <button class="secondary" data-dn="${p.id}">â†“</button>
            <button class="danger"    data-rm="${p.id}">Remove</button>
          `
              : ""
          }
        </div>
      `;
      participantsList.appendChild(row);
    });

    if (!participantsList.__bound) {
      participantsList.__bound = true;
      participantsList.addEventListener("click", (e) => {
        if (!amHost()) return;
        const t = e.target;
        if (!(t instanceof HTMLElement)) return;
        const upId = t.getAttribute("data-up");
        const dnId = t.getAttribute("data-dn");
        const rmId = t.getAttribute("data-rm");
        if (upId) return broadcast("move", { id: upId, delta: -1 });
        if (dnId) return broadcast("move", { id: dnId, delta: +1 });
        if (rmId) return broadcast("remove", { id: rmId });
      });
    }
  }

  function renderWheel() {
    const ids = state.participants;
    if (!ids.length) {
      namesLayer.innerHTML = "";
      nextNameEl.textContent = "â€”";
      turnInfoEl.textContent = `0/${state.tracks_per_turn}`;
      timerEl.textContent = formatMMSS(totalBudgetMs());
      rotatePointerToSlice(0);
      renderProgress();
      return;
    }
    const n = ids.length;
    const stops = ids.map(
      (p, i) => `${p.color} ${(i / n) * 360}deg ${((i + 1) / n) * 360}deg`
    );
    wheelEl.style.background = `conic-gradient(${stops.join(",")})`;
    namesLayer.innerHTML = "";
    ids.forEach((p, i) => {
      const tag = document.createElement("div");
      tag.className = "name-tag";
      tag.textContent = p.name;
      const angle = (i / n) * 360 + 180 / n;
      tag.style.transform = `rotate(${angle}deg) translateY(calc(var(--wheel-size) * -0.34)) rotate(${-angle}deg)`;
      namesLayer.appendChild(tag);
    });
    const sliceDeg = 360 / n;
    rotatePointerToSlice((state.active_index % n) * sliceDeg);
    nextNameEl.textContent = ids[state.active_index]?.name || "â€”";
    turnInfoEl.textContent = `${state.tracks_this_turn || 0}/${state.tracks_per_turn}`;
    renderProgress();
  }

  // Sweep wedge + hand (progress within the active slice)
  function renderProgress() {
    if (!progressLayer || !sweepHand) return;

    const n = state.participants.length;
    if (!n) {
      progressLayer.style.background = "none";
      sweepHand.innerHTML = "";
      return;
    }
    const sliceDeg = 360 / n;
    const startDeg = (state.active_index % n) * sliceDeg;

    // total budget is per-DJ: minutes * tracks_per_turn
    const total = totalBudgetMs();
    const elapsed = Math.max(0, total - Math.max(0, state.timer_ms || 0));
    const frac = Math.max(0, Math.min(1, elapsed / total));
    const endDeg = startDeg + frac * sliceDeg;

    const dark =
      state.phase === "grace" ? "rgba(239,68,68,.35)" : "rgba(2,6,23,.35)";
    progressLayer.style.background = `conic-gradient(
      transparent 0deg ${startDeg}deg,
      ${dark} ${startDeg}deg ${endDeg}deg,
      transparent ${endDeg}deg 360deg
    )`;

    sweepHand.innerHTML = `
      <div style="
        position:absolute; left:50%; top:50%;
        width:2px; height:calc(var(--wheel-size)/2 - 10px);
        background:${state.phase==='grace' ? '#ef4444' : '#e2e8f0'};
        transform-origin: bottom center;
        transform: translate(-50%,-100%) rotate(${endDeg}deg);
        opacity:.95; border-radius:2px; box-shadow:0 0 6px rgba(0,0,0,.4);
      "></div>
    `;
  }

  function renderAll() {
    renderParticipants();
    renderWheel();
    setStillBtnLabel();
  }

  // ----- Timer (host drives, guests display) -----
  let rafId = null,
    lastTick = null;

  function startDJTurn() {
    if (!amHost()) return;
    state.phase = "running";
    state.tracks_this_turn = 0;
    state.timer_ms = totalBudgetMs();
    lastTick = performance.now();
    loop();
    sync();
  }

  function extendPeriod(ms = msPerTrack()) {
    if (!amHost()) return;
    state.phase = "running";
    state.timer_ms = Math.max(0, state.timer_ms || 0) + ms;
    lastTick = performance.now();
    loop();
    sync();
  }

  function resetTurn() {
    if (!amHost()) return;
    cancelAnimationFrame(rafId);
    state.phase = "idle";
    state.timer_ms = totalBudgetMs();
    timerEl.textContent = formatMMSS(state.timer_ms);
    renderProgress();
    sync();
  }

  function loop() {
    cancelAnimationFrame(rafId);
    const step = () => {
      const now = performance.now();
      const dt = now - (lastTick || now);
      lastTick = now;
      state.timer_ms = Math.max(0, (state.timer_ms || 0) - dt);
      timerEl.textContent = formatMMSS(Math.floor(state.timer_ms));
      renderProgress();
      if (state.timer_ms <= 0) {
        handOver();
        return;
      }
      rafId = requestAnimationFrame(step);
    };
    rafId = requestAnimationFrame(step);
  }

  function handOver() {
    if (!amHost() || !state.participants.length) return;
    state.active_index = (state.active_index + 1) % state.participants.length;
    startDJTurn(); // full budget for next DJ
    sync();
  }

  function sync() {
    broadcast("state", state);
  }

  // ----- Channel setup -----
  async function setupChannel(roomId) {
    const room = roomId || sessionId;
    if (!room) return;

    if (channel && currentRoom && currentRoom !== room) {
      try {
        await channel.unsubscribe();
      } catch {}
      channel = null;
      currentRoom = null;
    }
    if (channel && currentRoom === room) return;

    channel = supabase.channel(`session:${room}`, {
      config: { presence: { key: me.id } },
    });
    currentRoom = room;

    // Host-only mutations
    channel.on("broadcast", { event: "upsert" }, ({ payload }) => {
      if (!amHost()) return;
      const i = state.participants.findIndex((p) => p.id === payload.id);
      if (i >= 0) state.participants[i] = payload;
      else state.participants.push(payload);
      renderAll();
      sync();
    });

    channel.on("broadcast", { event: "remove" }, ({ payload }) => {
      if (!amHost()) return;
      const idx = state.participants.findIndex((p) => p.id === payload.id);
      if (idx === -1) return;
      state.participants.splice(idx, 1);
      if (state.participants.length === 0) state.active_index = 0;
      else if (idx < state.active_index) state.active_index -= 1;
      else if (idx === state.active_index)
        state.active_index = state.active_index % state.participants.length;
      renderAll();
      sync();
    });

    channel.on("broadcast", { event: "move" }, ({ payload }) => {
      if (!amHost()) return;
      const i = state.participants.findIndex((p) => p.id === payload.id);
      if (i < 0) return;
      const j = Math.max(
        0,
        Math.min(state.participants.length - 1, i + (payload.delta || 0))
      );
      if (i === j) return;
      [state.participants[i], state.participants[j]] = [
        state.participants[j],
        state.participants[i],
      ];
      if (state.active_index === i) state.active_index = j;
      else if (state.active_index === j) state.active_index = i;
      renderAll();
      sync();
    });

    channel.on("broadcast", { event: "tpt" }, ({ payload }) => {
      if (!amHost()) return;
      state.tracks_per_turn = payload.v || 1;
      state.tracks_this_turn = 0;
      renderAll();
      sync();
    });

    channel.on("broadcast", { event: "mpt" }, ({ payload }) => {
      if (!amHost()) return;
      state.minutes_per_track = payload.v || 6;
      setStillBtnLabel();
      renderAll();
      sync();
    });

    channel.on("broadcast", { event: "handover" }, () => {
      if (amHost()) handOver();
    });

    // Snapshot handshake
    channel.on("broadcast", { event: "req_state" }, () => {
      if (amHost()) sync();
    });

    // Guests receive full state
    channel.on("broadcast", { event: "state" }, ({ payload }) => {
      if (amHost()) return; // host ignores its own echo
      state = payload;
      tracksSel.value = String(state.tracks_per_turn);
      minutesSel.value = String(state.minutes_per_track);
      renderAll();
      timerEl.textContent = formatMMSS(
        Math.floor(state.timer_ms || totalBudgetMs())
      );
    });

    // Presence: elect/repair host only if missing
    channel.on("presence", { event: "sync" }, () => {
      const pres = channel.presenceState?.() || {};
      const ids = Object.keys(pres);
      if (!state.host_id) {
        // First writer becomes host
        if (ids.includes(me.id)) {
          state.host_id = me.id;
          sync();
        }
      } else if (!ids.includes(state.host_id)) {
        // Host left â€” smallest UUID becomes host
        const newHost = ids.slice().sort()[0] || null;
        if (newHost && me.id === newHost) {
          state.host_id = newHost;
          sync();
        }
      }
      renderParticipants();
    });

    await channel.subscribe(async (status) => {
      console.log("[subscribe status]", status, "room=", room, "urlSessionId=", sessionId);
      if (status !== "SUBSCRIBED") return;
      isSubscribed = true;
      await channel.track({ ...me });

      // If no host yet (fresh room), take host and seed state
      if (!state.host_id) {
        state.host_id = me.id;
        const i = state.participants.findIndex((p) => p.id === me.id);
        if (i >= 0) state.participants[i] = me;
        else state.participants.push(me);
        tracksSel.value = String(state.tracks_per_turn);
        minutesSel.value = String(state.minutes_per_track);
        resetTurn(); // sets timer to totalBudgetMs
        sync();
      } else {
        // Guest asks host for snapshot
        broadcast("req_state", { ask: me.id });
      }

      renderAll();
    });

    // reconnect safety
    channel.on("system", { event: "channel_closed" }, () => setupChannel(room));
    channel.on("system", { event: "channel_error" }, () => setupChannel(room));
  }

  // ----- Actions -----
  $("newSessionBtn").onclick = () => {
    const id = crypto.randomUUID();
    history.replaceState(null, "", `/s/${id}`);
    sessionId = id;
    state.host_id = me.id; // creator is host
    setupChannel(sessionId);
    resetTurn();
    renderAll();
  };

  $("copyLinkBtn").onclick = async () => {
    await navigator.clipboard.writeText(`${ENV.BASE_URL}/s/${sessionId || ""}`);
    toast("Link copied");
  };

  $("joinBtn").onclick = () => {
    me.name = $("profileName").value.trim() || "DJ";
    me.avatar = $("avatarPick").value || "ninja";
    me.color = $("colorPick").value || "#7c3aed";
    saveMe();
    if (!sessionId) {
      toast("Create a session first");
      return;
    }
    if (!isSubscribed) {
      toast("Connectingâ€¦ try again");
      return;
    }

    channel.track({ ...me });
    if (amHost()) {
      const i = state.participants.findIndex((p) => p.id === me.id);
      if (i >= 0) state.participants[i] = me;
      else state.participants.push(me);
      renderAll();
      sync();
    } else {
      broadcast("upsert", { ...me });
    }
  };

  $("addGuestBtn").onclick = () => {
    if (!amHost()) return toast("Only host can add players here");
    const name = prompt("Guest DJ name?");
    if (!name) return;
    const ghost = {
      id: crypto.randomUUID(),
      name: name.trim(),
      avatar: "spaceman",
      color: "#22d3ee",
    };
    state.participants.push(ghost);
    renderAll();
    sync();
  };

  $("handOverBtn").onclick = () =>
    amHost() ? handOver() : broadcast("handover", {});
  $("stillBtn").onclick = () =>
    amHost() ? extendPeriod(msPerTrack()) : null;
  $("resetBtn").onclick = () => (amHost() ? resetTurn() : null);
  $("removeActiveBtn").onclick = () => {
    if (!amHost()) return;
    const active = state.participants[state.active_index];
    if (active) broadcast("remove", { id: active.id });
  };

  tracksSel.onchange = (e) => {
    const v = parseInt(e.target.value || "1", 10);
    if (!amHost()) {
      tracksSel.value = String(state.tracks_per_turn);
      return toast("Host only");
    }
    state.tracks_per_turn = Math.max(1, Math.min(3, v));
    setStillBtnLabel();
    renderAll();
    sync();
  };

  minutesSel.onchange = (e) => {
    const v = parseInt(e.target.value || "6", 10);
    if (!amHost()) {
      minutesSel.value = String(state.minutes_per_track);
      return toast("Host only");
    }
    state.minutes_per_track = Math.max(1, Math.min(60, v));
    setStillBtnLabel();
    if (state.phase === "idle") {
      timerEl.textContent = formatMMSS(totalBudgetMs());
      renderProgress();
    }
    broadcast("mpt", { v: state.minutes_per_track }); // guests adopt immediately
    renderAll();
    sync();
  };

  // ----- Init -----
  (function init() {
    $("profileName").value = me.name || "";
    $("avatarPick").value = me.avatar || "ninja";
    $("colorPick").value = me.color || "#7c3aed";
    tracksSel.value = String(state.tracks_per_turn);
    minutesSel.value = String(state.minutes_per_track);
    setStillBtnLabel();

    if (sessionId) {
      setupChannel(sessionId);
    }
  })();
</script>




