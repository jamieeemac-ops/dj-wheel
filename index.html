<script type="module">
  // ----- ENV -----
  const ENV = {
    SUPABASE_URL:  window.SUPABASE_URL  || "https://cdwyqogwbepscrgnopbw.supabase.co",
    SUPABASE_ANON_KEY: window.SUPABASE_ANON_KEY || "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNkd3lxb2d3YmVwc2NyZ25vcGJ3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTk0Njc2MTksImV4cCI6MjA3NTA0MzYxOX0.BhXTYwEoItlHvVoJ0kUB74kFFAWpwt0BZLRkbD96BBQ",
    BASE_URL: window.BASE_URL || window.location.origin
  };

  // ----- Libs -----
  import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

  // ----- Supabase Realtime -----
  const supabase = createClient(ENV.SUPABASE_URL, ENV.SUPABASE_ANON_KEY, { auth: { persistSession: true } });

  // ----- Local state -----
  const AVATAR_EMOJI = { ninja:'ðŸ¥·', robot:'ðŸ¤–', demon:'ðŸ˜ˆ', angel:'ðŸ˜‡', alien:'ðŸ‘½', pirate:'ðŸ´â€â˜ ï¸', wizard:'ðŸ§™â€â™‚ï¸' };
  const LS = "djwheel_rt_v1";
  let me = JSON.parse(localStorage.getItem(LS) || "null") || {
    id: crypto.randomUUID(), name: "", avatar: "ninja", color: "#b14cff"
  };

  let sessionId = getSessionIdFromPath(); // /s/:id or null
  let hostId = null; // chosen by first to create the session
  let state = { participants: [], active_index: 0, tracks_per_turn: 1, tracks_this_turn: 0, timer_ms: 8*60*1000, phase:"idle" };

  // UI refs
  const $ = (id)=>document.getElementById(id);
  const wheelEl=$('wheel'), namesLayer=$('namesLayer'), nextNameEl=$('nextName'),
        turnInfoEl=$('turnInfo'), timerEl=$('timer');

  // Channel + readiness flag
  let channel = null;
  let isSubscribed = false;

  // ----- PWA install -----
  let deferredPrompt;
  window.addEventListener('beforeinstallprompt', (e)=>{ e.preventDefault(); deferredPrompt = e; $('installBtn').hidden=false; });
  $('installBtn').onclick = async ()=>{ if(!deferredPrompt) return; deferredPrompt.prompt(); await deferredPrompt.userChoice; deferredPrompt=null; $('installBtn').hidden=true; };

  // ----- Helpers -----
  function getSessionIdFromPath(){ const m=location.pathname.match(/\/s\/([0-9a-fA-F-]+)/); return m?m[1]:null; }
  function saveMe(){ localStorage.setItem(LS, JSON.stringify(me)); }
  function isHost(){ return me.id === hostId; }
  function broadcast(type, payload){ channel?.send({ type:'broadcast', event:type, payload }); }
  function pickHostIfNeeded(){
    // Host is the smallest UUID among present users (deterministic), or existing host
    const ids = state.participants.map(p=>p.id);
    if (!hostId || !ids.includes(hostId)) {
      hostId = ids.slice().sort()[0] || me.id;
    }
  }

  // ----- Wheel render -----
  function renderWheel(){
    const ids = state.participants;
    if (!ids.length){
      wheelEl.style.background = 'conic-gradient(#333 0 360deg)';
      namesLayer.innerHTML=''; nextNameEl.textContent='â€”';
      turnInfoEl.textContent=`${state.tracks_this_turn}/${state.tracks_per_turn}`; return;
    }
    const n = ids.length;
    const stops = ids.map((p,i)=>`${p.color} ${(i/n)*360}deg ${((i+1)/n)*360}deg`);
    wheelEl.style.background = `conic-gradient(${stops.join(',')})`;
    namesLayer.innerHTML='';
    ids.forEach((p,i)=>{
      const tag=document.createElement('div'); tag.className='name-tag';
      tag.innerHTML = `<span class="avatar">${AVATAR_EMOJI[p.avatar]||'ðŸŽ§'}</span>${p.name}`;
      const angle = (i/n)*360 + (180/n);
      tag.style.transform = `rotate(${angle}deg) translateY(calc(var(--wheel-size) * -0.34)) rotate(${-angle}deg)`;
      namesLayer.appendChild(tag);
    });
    const deg=(state.active_index/n)*360; wheelEl.style.transform=`rotate(${-deg}deg)`;
    nextNameEl.textContent = ids[state.active_index]?.name || 'â€”';
    turnInfoEl.textContent = `${state.tracks_this_turn}/${state.tracks_per_turn}`;
  }
  function renderParticipants(){
    const el=$('participantsList'); el.innerHTML='';
    state.participants.forEach((p,i)=>{
      const row=document.createElement('div'); row.className='item';
      row.innerHTML = `
        <div>${AVATAR_EMOJI[p.avatar]||'ðŸŽ§'} ${p.name}
          <span style="display:inline-block;width:14px;height:14px;border-radius:50%;border:1px solid #333;background:${p.color};margin-left:6px;"></span>
          <small class="muted"> (pos ${i}) ${p.id===hostId?' â€¢ Host':''}</small>
        </div>
        <div class="row">
          ${isHost()?`<button class="secondary" data-up="${p.id}">â†‘</button>
          <button class="secondary" data-dn="${p.id}">â†“</button>
          <button class="secondary" data-rm="${p.id}">Remove</button>`:''}
        </div>`;
      el.appendChild(row);
    });
    if (isHost()){
      el.querySelectorAll('button[data-rm]').forEach(b=>b.onclick=()=>{ broadcast('remove', { id:b.getAttribute('data-rm') }); });
      el.querySelectorAll('button[data-up]').forEach(b=>b.onclick=()=>{ broadcast('move', { id:b.getAttribute('data-up'), delta:-1 }); });
      el.querySelectorAll('button[data-dn]').forEach(b=>b.onclick=()=>{ broadcast('move', { id:b.getAttribute('data-dn'), delta:+1 }); });
    }
  }
  function renderAll(){ pickHostIfNeeded(); renderParticipants(); renderWheel(); }

  // ----- Timer (host drives it; others display-only) -----
  let rafId=null, lastTick=null;
  function startPeriod(){ if(!isHost()) return; state.phase="running"; state.timer_ms=8*60*1000; lastTick=performance.now(); loop(); sync(); }
  function startGrace(){ if(!isHost()) return; state.phase="grace"; state.timer_ms=60*1000; lastTick=performance.now(); loop(); sync(); }
  function loop(){
    cancelAnimationFrame(rafId);
    const step = ()=>{
      const now=performance.now(); const dt=now-(lastTick||now); lastTick=now;
      state.timer_ms=Math.max(0,(state.timer_ms||0)-dt);
      renderTimer();
      if(state.timer_ms<=0){
        if(state.phase==='running') startGrace();
        else if(state.phase==='grace') handOver(true);
        return;
      }
      rafId=requestAnimationFrame(step);
    };
    rafId=requestAnimationFrame(step);
  }
  function renderTimer(){
    const ms = Math.max(0, Math.floor(state.timer_ms||0));
    const m = Math.floor(ms/60000); const s = Math.floor((ms%60000)/1000);
    $('timer').textContent = `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
  }
  function sync(){ broadcast('state', state); }

  // ----- Actions -----
  $('newSessionBtn').onclick = async ()=>{
    const id = crypto.randomUUID();
    history.replaceState(null,"",`/s/${id}`);
    sessionId = id; setupChannel();
  };
  $('copyLinkBtn').onclick = async ()=>{
    if(!sessionId) return alert("Create a session first");
    await navigator.clipboard.writeText(`${ENV.BASE_URL}/s/${sessionId}`); toast("Link copied");
  };
  $('tracksPerTurn').onchange = (e)=> isHost() && broadcast('tpt', { v: parseInt(e.target.value||'1',10) });
  $('removeActiveBtn').onclick = ()=> isHost() && broadcast('remove', { id: state.participants[state.active_index]?.id });
  $('handOverBtn').onclick = ()=> isHost() ? handOver(false) : broadcast('handover', {});
  $('stillBtn').onclick = ()=> isHost() && startPeriod();
  $('resetBtn').onclick = ()=> isHost() && (state.tracks_this_turn=0, sync());

  function handOver(auto){
    if(!isHost()) return;
    if(!state.participants.length) return;
    if (state.tracks_this_turn + 1 >= state.tracks_per_turn) {
      state.tracks_this_turn = 0;
      state.active_index = (state.active_index + 1) % state.participants.length;
    } else {
      state.tracks_this_turn++;
    }
    startPeriod(); // new window
    sync();
  }

  // ----- Supabase channel setup -----
  async function setupChannel() {
    isSubscribed = false;

    // tear down old channel
    try { channel?.unsubscribe(); } catch {}

    const topic = `session:${sessionId}`;
    channel = supabase.channel(topic, {
      config: { presence: { key: me.id } }
    });

    // --- Host-only mutations, then broadcast full state ---
    channel.on('broadcast', { event: 'upsert' }, ({ payload }) => {
      if (!isHost()) return;
      const i = state.participants.findIndex(p => p.id === payload.id);
      if (i >= 0) state.participants[i] = payload;
      else state.participants.push(payload);
      renderAll();
      sync(); // send full state to everyone
    });

    channel.on('broadcast', { event: 'remove' }, ({ payload }) => {
      if (!isHost()) return;
      state.participants = state.participants.filter(p => p.id !== payload.id);
      if (state.active_index >= state.participants.length) state.active_index = 0;
      renderAll();
      sync();
    });

    channel.on('broadcast', { event: 'move' }, ({ payload }) => {
      if (!isHost()) return;
      const i = state.participants.findIndex(p => p.id === payload.id);
      const j = i + (payload.delta || 0);
      if (i < 0 || j < 0 || j >= state.participants.length) return;
      [state.participants[i], state.participants[j]] = [state.participants[j], state.participants[i]];
      renderAll();
      sync();
    });

    channel.on('broadcast', { event: 'tpt' }, ({ payload }) => {
      if (!isHost()) return;
      state.tracks_per_turn = payload.v || 1;
      state.tracks_this_turn = 0;
      renderAll();
      sync();
    });

    channel.on('broadcast', { event: 'handover' }, () => {
      if (!isHost()) return;
      handOver(false);
    });

    // --- Non-hosts receive the authoritative state from host ---
    channel.on('broadcast', { event: 'state' }, ({ payload }) => {
      if (isHost()) return;           // host is the source of truth
      state = payload;
      renderAll();
      renderTimer();
    });

    // --- Presence: who is online (optional UI) ---
    channel.on('presence', { event: 'sync' }, () => {
      const pres = channel.presenceState();
      const ids = Object.keys(pres || {});
      if (!hostId || !ids.includes(hostId)) {
        hostId = ids.slice().sort()[0] || me.id; // smallest UUID wins
      }
      renderParticipants();
    });

    // --- Subscribe & announce presence ---
    await channel.subscribe(async (status) => {
      if (status === 'SUBSCRIBED') {
        isSubscribed = true;

        // announce myself
        await channel.track({ ...me });

        // first joiner becomes host
        if (!hostId) hostId = me.id;

        if (isHost()) {
          // ensure host is in the list
          const i = state.participants.findIndex(p => p.id === me.id);
          if (i >= 0) state.participants[i] = me;
          else state.participants.push(me);

          // nudge initial state & start timer window
          state.participants ||= [];
          const tptEl = document.getElementById('tracksPerTurn');
          if (tptEl) tptEl.value = String(state.tracks_per_turn);
          sync();        // broadcast full state
          startPeriod(); // start timer
        }

        renderAll();
        renderTimer();
      }
    });
  }

  // Heartbeat (optional): host rebroadcasts every 10s for reliability
  if (!window.__djHeartbeat) {
    window.__djHeartbeat = setInterval(() => {
      if (isHost() && channel && isSubscribed) sync();
    }, 10000);
  }

  // ----- Join / Update -----
  $('joinBtn').onclick = () => {
    if (!sessionId) {
      toast("Create a session first (New Session) or open a session link.");
      return;
    }
    if (!channel || !isSubscribed) {
      toast("Connectingâ€¦ try Join again in a second.");
      return;
    }

    me.name   = $('profileName').value.trim() || 'DJ';
    me.avatar = $('avatarPick').value || 'ninja';
    me.color  = $('colorPick').value || '#b14cff';
    saveMe();

    // presence update (safe to repeat)
    channel.track({ ...me });

    if (isHost()) {
      // update local and broadcast full state
      const i = state.participants.findIndex(p => p.id === me.id);
      if (i >= 0) state.participants[i] = me;
      else state.participants.push(me);
      renderAll();
      sync();
    } else {
      // ask host to upsert me
      broadcast('upsert', { ...me });
    }
  };

  // ----- Basic toast -----
  function toast(msg){
    const t = document.createElement('div');
    t.style.cssText = "position:fixed;bottom:14px;left:50%;transform:translateX(-50%);background:#111;color:#fff;padding:10px 14px;border-radius:8px;border:1px solid #2a2a2a;";
    t.textContent = msg; document.body.appendChild(t);
    setTimeout(()=>t.remove(),1800);
  }

  // ----- Init -----
  (async function init(){
    if('serviceWorker' in navigator){ try{ await navigator.serviceWorker.register('/service-worker.js'); }catch{} }
    $('profileName').value = me.name || "";
    $('avatarPick').value  = me.avatar || "ninja";
    $('colorPick').value   = me.color || "#b14cff";

    if (sessionId) setupChannel();
  })();
</script>


