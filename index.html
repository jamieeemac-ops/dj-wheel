<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#0a0f1a" />
  <title>Who‚Äôs up next?</title>
  <style>
    :root{
      --bg:#0a0f1a; --panel:#0f172a; --panel-border:#1e293b; --muted:#94a3b8; --text:#e2e8f0;
      --accent:#7c3aed; --success:#22c55e; --danger:#ef4444; --wheel-size:340px;
    }
    *{ box-sizing:border-box; }
    body{ margin:0; font-family: ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
      background: radial-gradient(1000px 800px at 10% -20%,rgba(124,58,237,.2),transparent 50%),
                  radial-gradient(800px 600px at 110% 10%,rgba(34,211,238,.15),transparent 50%),
                  var(--bg); color:var(--text);}
    header{padding:12px 16px;border-bottom:1px solid var(--panel-border);display:flex;align-items:center;justify-content:space-between;
      background:linear-gradient(180deg,rgba(10,15,26,.9),rgba(10,15,26,.7));backdrop-filter:blur(6px);}
    h1{margin:0;font-size:18px;font-weight:800;}
    main{padding:16px;display:grid;gap:16px;max-width:1080px;margin:0 auto;}
    .panel{background:linear-gradient(180deg,rgba(15,23,42,.96),rgba(15,23,42,.92));border:1px solid var(--panel-border);
      border-radius:14px;padding:12px;box-shadow:0 6px 20px rgba(0,0,0,.25);}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;}
    input,select{padding:10px 12px;border-radius:10px;border:1px solid var(--panel-border);background:#0b1224;color:#fff;}
    button{padding:10px 14px;border:0;border-radius:10px;font-weight:700;cursor:pointer;transition:.15s;}
    button.primary{background:var(--accent);color:#fff;}
    button.secondary{background:#1f2937;color:#e5e7eb;}
    button.success{background:var(--success);color:#fff;}
    button.danger{background:var(--danger);color:#fff;}
    .muted{color:var(--muted)}
    .badge{font-size:12px;padding:6px 10px;border-radius:999px;border:1px solid #1f2a44;background:#0b1224;}
    .badge.ok{ background:rgba(34,197,94,.15); color:#86efac; border-color:#16a34a; }
    .badge.warn{ background:rgba(234,179,8,.15); color:#fde68a; border-color:#ca8a04; }

    .wheel-wrap{position:relative;width:var(--wheel-size);height:var(--wheel-size);margin:0 auto;}
    .wheel{width:100%;height:100%;border-radius:50%;border:8px solid rgba(226,232,240,.98);display:grid;place-items:center;
      overflow:hidden;position:relative;background:conic-gradient(#334155 0 360deg);}
    .pointer-ring{position:absolute;inset:-8px;border-radius:50%;z-index:6;pointer-events:none;transition:transform .6s cubic-bezier(.25,.9,.2,1);}
    .pointer{position:absolute;top:-8px;left:calc(50% - 10px);width:0;height:0;border-left:10px solid transparent;border-right:10px solid transparent;border-bottom:16px solid #e2e8f0;}
    .center-label{position:absolute;width:170px;height:170px;border-radius:50%;background:#0b1224;border:2px solid #334155;
      display:grid;place-items:center;text-align:center;padding:8px;z-index:3;color:#fff;}
    .names-layer{position:absolute;inset:0;display:grid;place-items:center;pointer-events:none;z-index:2;}
    .name-tag{position:absolute;font-size:12px;font-weight:700;background:rgba(2,6,23,.55);padding:4px 6px;border-radius:6px;
      transform-origin:50% calc(var(--wheel-size) * -0.34);color:#fff;text-shadow:0 1px 2px rgba(0,0,0,.6);}
    .list{display:grid;gap:8px;}
    .item{background:linear-gradient(180deg,rgba(11,18,36,.96),rgba(11,18,36,.92));border:1px solid #1f2a44;padding:10px;border-radius:12px;
      display:flex;align-items:center;justify-content:space-between;}
  </style>
</head>
<body>
  <header>
    <h1>Who‚Äôs up next?</h1>
    <div class="row">
      <span id="connBadge" class="badge warn">Connecting‚Ä¶</span>
      <div class="row">
        <button class="secondary" id="copyLinkBtn">Copy Link</button>
        <button class="secondary" id="newSessionBtn">New Session</button>
      </div>
    </div>
  </header>

  <main class="grid grid-2">
    <!-- Wheel -->
    <section class="panel">
      <h2>Wheel</h2>
      <div class="wheel-wrap">
        <div id="pointerRing" class="pointer-ring"><div class="pointer"></div></div>
        <div id="wheel" class="wheel">
          <div class="center-label">
            <div>
              <div class="muted">Next Up</div>
              <h2 id="nextName">‚Äî</h2>
              <small class="muted">Tracks: <span id="turnInfo">0/1</span></small><br/>
              <small class="muted">Timer: <span class="timer" id="timer">06:00</span></small>
            </div>
          </div>
          <div id="progressLayer" style="position:absolute;inset:0;border-radius:50%;pointer-events:none;z-index:4;"></div>
          <div id="sweepHand" style="position:absolute;inset:0;border-radius:50%;z-index:5;pointer-events:none;"></div>
          <div id="namesLayer" class="names-layer"></div>
        </div>
      </div>

      <div class="row" style="justify-content:center;margin-top:12px;">
        <button id="handOverBtn" class="primary">Hand Over</button>
        <button id="stillBtn" class="secondary">Still Mixing (+6m)</button>
        <button id="resetBtn" class="secondary">Reset</button>
        <button id="removeActiveBtn" class="danger">Remove Active</button>
      </div>

      <div class="row" style="justify-content:center;margin-top:8px;">
        <label>Tracks per turn:
          <select id="tracksPerTurn">
            <option value="1" selected>1</option><option value="2">2</option><option value="3">3</option>
          </select>
        </label>
        <label>Minutes per track:
          <select id="minutesPerTrack">
            <option value="4">4</option><option value="5">5</option>
            <option value="6" selected>6</option>
            <option value="7">7</option><option value="8">8</option>
            <option value="9">9</option><option value="10">10</option>
          </select>
        </label>
      </div>
    </section>

    <!-- Players -->
    <section class="panel">
      <h2>Players</h2>
      <div class="row">
        <input id="profileName" type="text" placeholder="Your DJ name" />
        <select id="avatarPick" title="Avatar">
          <option value="ninja">ü•∑ Ninja</option>
          <option value="robot">ü§ñ Robot</option>
          <option value="demon">üòà Demon</option>
          <option value="angel">üòá Angel</option>
          <option value="alien">üëΩ Alien</option>
          <option value="pirate">üè¥‚Äç‚ò†Ô∏è Pirate</option>
          <option value="wizard">üßô‚Äç‚ôÇÔ∏è Wizard</option>
          <option value="spaceman">üßë‚ÄçüöÄ Spaceman</option>
        </select>
        <input id="colorPick" type="color" value="#7c3aed" />
        <button id="joinBtn" class="success">Join / Update</button>
        <button id="addGuestBtn" class="secondary">+ Add Player</button>
      </div>
      <div id="participantsList" class="list" style="margin-top:12px;"></div>
    </section>
  </main>

  <!-- ================= SCRIPT ================= -->
  <script type="module">
    // ----- ENV -----
    const ENV = {
      SUPABASE_URL:  "https://cdwyqogwbepscrgnopbw.supabase.co",
      SUPABASE_ANON_KEY: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNkd3lxb2d3YmVwc2NyZ25vcGJ3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTk0Njc2MTksImV4cCI6MjA3NTA0MzYxOX0.BhXTYwEoItlHvVoJ0kUB74kFFAWpwt0BZLRkbD96BBQ",
      BASE_URL: window.location.origin
    };
    import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm";

    // ----- Helpers / constants -----
    const $ = (id)=>document.getElementById(id);
    const AVATAR_EMOJI = { ninja:'ü•∑', robot:'ü§ñ', demon:'üòà', angel:'üòá', alien:'üëΩ', pirate:'üè¥‚Äç‚ò†Ô∏è', wizard:'üßô‚Äç‚ôÇÔ∏è', spaceman:'üßë‚ÄçüöÄ' };
    const LS = "djwheel_rt_v6";
    const fmt = (ms)=>{ const m=Math.floor(ms/60000), s=Math.floor((ms%60000)/1000); return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`; };
    const sessionFromPath = ()=> { const m=location.pathname.match(/\/s\/([0-9a-fA-F-]+)/); return m?m[1]:null; };
    const toast = (msg)=>{ const t=document.createElement('div'); t.style.cssText="position:fixed;bottom:14px;left:50%;transform:translateX(-50%);background:#0b1224;color:#e2e8f0;padding:10px 14px;border-radius:8px;border:1px solid #1f2a44;z-index:9999"; t.textContent=msg; document.body.appendChild(t); setTimeout(()=>t.remove(),1600); };

    // ----- Local profile -----
    let me = JSON.parse(localStorage.getItem(LS) || "null") || { id: crypto.randomUUID(), name:"", avatar:"ninja", color:"#7c3aed" };
    const saveMe = ()=> localStorage.setItem(LS, JSON.stringify(me));

    // ----- Shared state -----
    let state = {
      host_id: null,
      participants: [],
      active_index: 0,
      tracks_per_turn: 1,
      minutes_per_track: 6,   // host edits this in UI
      tracks_this_turn: 0,
      timer_ms: 0,
      turn_total_ms: 0,       // FROZEN total for current DJ turn
      phase: "idle"
    };
    const msPerTrack = ()=> state.minutes_per_track * 60 * 1000;
    const totalBudgetMs = ()=> msPerTrack() * state.tracks_per_turn;
    const amHost = ()=> state.host_id && me.id === state.host_id;

    // Host/guest handshake flags
    let receivedState = false;  // set true when we receive snapshot from host
    let isCreator     = false;  // true only for the tab that clicks "New Session"

    // ----- UI refs -----
    const wheelEl=$('wheel'), namesLayer=$('namesLayer'), nextNameEl=$('nextName'),
          turnInfoEl=$('turnInfo'), timerEl=$('timer'), pointerRing=$('pointerRing'),
          progressLayer=$('progressLayer'), sweepHand=$('sweepHand'),
          participantsList=$('participantsList'), stillBtn=$('stillBtn'),
          minutesSel=$('minutesPerTrack'), tracksSel=$('tracksPerTurn'),
          connBadge=$('connBadge');

    const setStillBtnLabel = ()=> stillBtn.textContent = `Still Mixing (+${state.minutes_per_track}m)`;
    function updateConnBadge(){
      const ok   = !!isSubscribed;
      const role = amHost() ? 'Host' : 'Guest';
      connBadge.classList.toggle('ok', ok);
      connBadge.classList.toggle('warn', !ok);
      connBadge.textContent = ok ? `Connected ‚Ä¢ ${role}` : 'Connecting‚Ä¶';
    }

    // ----- Supabase Realtime -----
    const supabase = createClient(ENV.SUPABASE_URL, ENV.SUPABASE_ANON_KEY, { auth: { persistSession: true } });
    let channel=null, sessionId=sessionFromPath(), isSubscribed=false, currentRoom=null;
    const broadcast = (event, payload)=> channel && currentRoom===sessionId && channel.send({ type:'broadcast', event, payload });

    // ----- Rendering -----
    function rotatePointerToSlice(deg){ pointerRing.style.transform = `rotate(${deg}deg)`; }

    function renderParticipants(){
      participantsList.innerHTML = '';
      state.participants.forEach((p,i)=>{
        const row=document.createElement('div'); row.className='item';
        row.innerHTML = `
          <div>${AVATAR_EMOJI[p.avatar]||'üéß'} ${p.name}
            <span style="display:inline-block;width:14px;height:14px;border-radius:50%;border:1px solid #1f2a44;background:${p.color};margin-left:6px;"></span>
            <small class="muted"> (pos ${i+1}) ${p.id===state.host_id?' ‚Ä¢ Host':''}</small>
          </div>
          <div class="row">
            ${amHost()?`<button class="secondary" data-up="${p.id}">‚Üë</button>
            <button class="secondary" data-dn="${p.id}">‚Üì</button>
            <button class="danger" data-rm="${p.id}">Remove</button>`:''}
          </div>`;
        participantsList.appendChild(row);
      });
      if (!participantsList.__bound){
        participantsList.__bound = true;
        participantsList.addEventListener('click', (e)=>{
          const btn = (e.target instanceof HTMLElement) ? e.target.closest('button') : null;
          if (!btn) return;
          const upId = btn.getAttribute('data-up');
          const dnId = btn.getAttribute('data-dn');
          const rmId = btn.getAttribute('data-rm');
          if (amHost()){
            if (upId) return hostMoveParticipant(upId, -1);
            if (dnId) return hostMoveParticipant(dnId, +1);
            if (rmId) return hostRemoveParticipant(rmId);
          } else {
            if (upId) return broadcast('move',   { id: upId, delta: -1 });
            if (dnId) return broadcast('move',   { id: dnId, delta: +1 });
            if (rmId) return broadcast('remove', { id: rmId });
          }
        });
      }
    }

    function renderWheel(){
      const ids=state.participants;
      if (!ids.length){
        namesLayer.innerHTML=''; nextNameEl.textContent='‚Äî';
        turnInfoEl.textContent=`0/${state.tracks_per_turn}`;
        timerEl.textContent = fmt(totalBudgetMs());
        rotatePointerToSlice(0);
        renderProgress();
        return;
      }
      const n=ids.length;
      const stops=ids.map((p,i)=>`${p.color} ${(i/n)*360}deg ${((i+1)/n)*360}deg`);
      wheelEl.style.background = `conic-gradient(${stops.join(',')})`;
      namesLayer.innerHTML='';
      ids.forEach((p,i)=>{
        const tag=document.createElement('div'); tag.className='name-tag';
        tag.textContent=p.name;
        const angle=(i/n)*360 + (180/n);
        tag.style.transform=`rotate(${angle}deg) translateY(calc(var(--wheel-size) * -0.34)) rotate(${-angle}deg)`;
        namesLayer.appendChild(tag);
      });
      const sliceDeg=360/n;
      rotatePointerToSlice((state.active_index % n) * sliceDeg);
      nextNameEl.textContent = ids[state.active_index]?.name || '‚Äî';
      turnInfoEl.textContent = `${state.tracks_this_turn||0}/${state.tracks_per_turn}`;
      renderProgress();
    }

    function renderProgress(){
      const n=state.participants.length;
      if (!n){ progressLayer.style.background='none'; sweepHand.innerHTML=''; return; }
      const sliceDeg=360/n, startDeg=(state.active_index % n) * sliceDeg;
      const total = state.turn_total_ms || totalBudgetMs();
      const elapsed = Math.max(0, total - Math.max(0, state.timer_ms||0));
      const frac = Math.max(0, Math.min(1, elapsed/total));
      const endDeg=startDeg + frac*sliceDeg;
      const dark='rgba(2,6,23,.35)';
      progressLayer.style.background = `conic-gradient(
        transparent 0deg ${startDeg}deg,
        ${dark} ${startDeg}deg ${endDeg}deg,
        transparent ${endDeg}deg 360deg
      )`;
      sweepHand.innerHTML = `<div style="
        position:absolute; left:50%; top:50%; width:2px; height:calc(var(--wheel-size)/2 - 10px);
        background:#e2e8f0; transform-origin:bottom center; transform:translate(-50%,-100%) rotate(${endDeg}deg);
        opacity:.95; border-radius:2px; box-shadow:0 0 6px rgba(0,0,0,.4);
      "></div>`;
    }

    function renderAll(){ renderParticipants(); renderWheel(); setStillBtnLabel(); }

    // ----- Timer (host drives) + guest animation -----
    let rafId=null, lastTick=null, lastTurnStartMs=0, handoverConfirmArmed=false;

    function loop(){
      cancelAnimationFrame(rafId);
      const step=()=>{
        const now=performance.now(), dt=now-(lastTick||now); lastTick=now;
        state.timer_ms=Math.max(0,(state.timer_ms||0)-dt);
        timerEl.textContent=fmt(Math.floor(state.timer_ms));
        renderProgress();
        if (state.timer_ms<=0){ handOver(); return; }
        rafId=requestAnimationFrame(step);
      };
      rafId=requestAnimationFrame(step);
    }

    function startGuestLoop(){
      if (amHost()) return;            // guests animate locally
      cancelAnimationFrame(rafId);
      const step = ()=>{
        if (!state.timer_ms) return;
        state.timer_ms = Math.max(0, state.timer_ms - 1000/30); // ~30fps
        timerEl.textContent = fmt(Math.floor(state.timer_ms));
        renderProgress();
        rafId = requestAnimationFrame(step);
      };
      rafId = requestAnimationFrame(step);
    }

    function startDJTurn(){
      if(!amHost()) return;
      state.phase = 'running';
      state.tracks_this_turn = 0;
      state.turn_total_ms = totalBudgetMs();   // freeze total for this turn
      state.timer_ms      = state.turn_total_ms;
      lastTurnStartMs = Date.now();

      renderAll();                              // pointer & Next Up update now
      lastTick = performance.now();
      loop();
      sync();
    }

    function extendPeriod(ms = msPerTrack()){
      if(!amHost()) return;
      state.phase='running';
      state.turn_total_ms += ms;               // keep denom in sync
      state.timer_ms      += ms;               // add to remaining
      lastTick=performance.now();
      loop(); sync();
    }

    function resetTurn(){
      if(!amHost()) return;
      cancelAnimationFrame(rafId);
      state.phase='idle';
      state.turn_total_ms = totalBudgetMs();
      state.timer_ms      = state.turn_total_ms;
      timerEl.textContent=fmt(state.timer_ms);
      renderProgress(); sync();
    }

    function handOver(){
      if(!amHost()||!state.participants.length) return;
      state.active_index=(state.active_index+1)%state.participants.length;
      renderAll();                              // update pointer/Next Up now
      startDJTurn();                            // timer + loop
      const next = state.participants[state.active_index];
      if (next) notifyNextDJ(next);            // push (no-op if not configured)
      // sync() already in startDJTurn()
    }

    const sync = ()=> broadcast('state', state);

    // ----- Host-local mutate helpers -----
    function hostMoveParticipant(id, delta){
      const i = state.participants.findIndex(p=>p.id===id);
      if (i < 0) return;
      const j = Math.max(0, Math.min(state.participants.length-1, i + (delta||0)));
      if (i === j) return;
      [state.participants[i], state.participants[j]] = [state.participants[j], state.participants[i]];
      if (state.active_index === i) state.active_index = j;
      else if (state.active_index === j) state.active_index = i;
      renderAll(); sync();
    }
    function hostRemoveParticipant(id){
      const idx = state.participants.findIndex(p=>p.id===id);
      if (idx === -1) return;
      state.participants.splice(idx, 1);
      if (state.participants.length === 0) state.active_index = 0;
      else if (idx < state.active_index) state.active_index -= 1;
      else if (idx === state.active_index) state.active_index %= state.participants.length;
      renderAll(); sync();
    }
    function isMyTurn(){
      const p = state.participants[state.active_index];
      return !!p && p.id === me.id;
    }

    // ----- Channel setup -----
    async function setupChannel(roomId){
      const room = roomId || sessionId; if(!room) return;
      if (channel && currentRoom && currentRoom!==room){ try{ await channel.unsubscribe(); }catch{} channel=null; currentRoom=null; }
      if (channel && currentRoom===room) return;

      channel = supabase.channel(`session:${room}`, { config:{ presence:{ key: me.id } } });
      currentRoom = room; isSubscribed=false; updateConnBadge();

      // Host-only mutations
      channel.on('broadcast', { event:'upsert' }, ({payload})=>{
        if(!amHost())return;
        const i=state.participants.findIndex(p=>p.id===payload.id);
        if(i>=0) state.participants[i]=payload; else state.participants.push(payload);
        renderAll(); sync();
      });
      channel.on('broadcast', { event:'remove' }, ({payload})=>{
        if(!amHost())return; hostRemoveParticipant(payload.id);
      });
      channel.on('broadcast', { event:'move' }, ({payload})=>{
        if(!amHost())return; hostMoveParticipant(payload.id, payload.delta);
      });
      channel.on('broadcast', { event:'tpt' }, ({payload})=>{
        if(!amHost())return; state.tracks_per_turn=payload.v||1; state.tracks_this_turn=0; renderAll(); sync();
      });
      channel.on('broadcast', { event:'mpt' }, ({payload})=>{
        if(!amHost())return; state.minutes_per_track=payload.v||6; setStillBtnLabel();
        if(state.phase==='idle'){ state.turn_total_ms=totalBudgetMs(); timerEl.textContent=fmt(state.turn_total_ms); renderProgress(); }
        renderAll(); sync();
      });
      channel.on('broadcast', { event:'handover' }, ()=>{
        if (amHost()) handOver();
      });
      channel.on('broadcast', { event:'req_state' }, ()=>{ if(amHost()) sync(); });

      // Guests adopt full state + start local animation
      channel.on('broadcast', { event:'state' }, ({payload})=>{
        if (amHost()) return;
        receivedState = true;  // snapshot received
        state = payload;
        tracksSel.value = String(state.tracks_per_turn);
        minutesSel.value = String(state.minutes_per_track);
        renderAll();
        timerEl.textContent = fmt(Math.floor(state.timer_ms || totalBudgetMs()));
        updateConnBadge();
        startGuestLoop();      // animate locally
      });

      // Presence repair (only if host existed and left)
      channel.on('presence', { event:'sync' }, ()=>{
        const pres = channel.presenceState?.() || {}; const ids = Object.keys(pres);
        if (state.host_id && !ids.includes(state.host_id)){
          const newHost = ids.slice().sort()[0] || null;
          if (newHost && me.id===newHost){ state.host_id=newHost; sync(); }
        }
        renderParticipants(); updateConnBadge();
      });

      await channel.subscribe(async (status)=>{
        console.log('[subscribe status]', status, 'room=', room, 'urlSessionId=', sessionId);
        if (status!=='SUBSCRIBED') return;
        isSubscribed = true; updateConnBadge();
        await channel.track({ ...me });

        // Ask for snapshot; only self-elect if creator AND alone AND no snapshot in 2s
        receivedState = false;
        broadcast('req_state', { ask: me.id });
        clearTimeout(window.__snapshotTimer);
        window.__snapshotTimer = setTimeout(()=>{
          if (receivedState || state.host_id) return;
          const pres = channel.presenceState?.() || {}; const ids = Object.keys(pres);
          if (ids.length===1 && ids[0]===me.id && isCreator) {
            state.host_id = me.id;
            resetTurn(); sync();
          }
        }, 2000);

        renderAll(); updateConnBadge();
      });

      channel.on('system', { event:'channel_closed' }, ()=> setupChannel(room));
      channel.on('system', { event:'channel_error' },  ()=> setupChannel(room));
    }

    // ----- Host heartbeat (drift correction for guests) -----
    if (!window.__djHeartbeat){
      window.__djHeartbeat = setInterval(()=>{
        if (amHost() && channel && isSubscribed && currentRoom === sessionId){
          sync();    // rebroadcast every 10s
        }
      }, 10_000);
    }

    // ----- Actions -----
    $('newSessionBtn').onclick = ()=>{
      const id = crypto.randomUUID();
      history.replaceState(null,"",`/s/${id}`);
      sessionId = id;

      isCreator = true;          // I created this room
      state.host_id = me.id;     // I am the host

      $('newSessionBtn').disabled = true; // avoid accidental second room
      setupChannel(sessionId);
      resetTurn(); renderAll(); updateConnBadge();
    };

    $('copyLinkBtn').onclick = async ()=>{ await navigator.clipboard.writeText(`${ENV.BASE_URL}/s/${sessionId||''}`); toast('Link copied'); };

    $('joinBtn').onclick = ()=>{
      me.name = $('profileName').value.trim() || 'DJ';
      me.avatar = $('avatarPick').value || 'ninja';
      me.color  = $('colorPick').value || '#7c3aed';
      saveMe(); setupPush();

      if (!sessionId) return toast('Create a session first');
      if (!isSubscribed) return toast('Connecting‚Ä¶ try again');

      channel.track({ ...me });
      if (amHost()){
        const i=state.participants.findIndex(p=>p.id===me.id); if(i>=0) state.participants[i]=me; else state.participants.push(me);
        renderAll(); sync();
      } else {
        broadcast('upsert', { ...me });
      }
    };

    $('addGuestBtn').onclick = ()=>{
      if (!amHost()) return toast('Only host can add players here');
      const name = prompt('Guest DJ name?'); if (!name) return;
      const ghost = { id: crypto.randomUUID(), name:name.trim(), avatar:'spaceman', color:'#22d3ee' };
      state.participants.push(ghost); renderAll(); sync();
    };

    $('handOverBtn').onclick = () => {
      // Only host or the ACTIVE DJ can hand over
      if (!amHost() && !isMyTurn()){
        return toast('Only the host or the active DJ can hand over');
      }
      const now = Date.now();
      const sinceTurnStart = now - (lastTurnStartMs || 0);
      if (sinceTurnStart < 60_000 && !handoverConfirmArmed){
        handoverConfirmArmed = true;
        $('handOverBtn').classList.add('danger');
        $('handOverBtn').textContent = 'Confirm Hand Over';
        toast('Press again to confirm');
        setTimeout(()=>{
          if (!handoverConfirmArmed) return;
          handoverConfirmArmed = false;
          $('handOverBtn').classList.remove('danger');
          $('handOverBtn').textContent = 'Hand Over';
        }, 5000);
        return;
      }
      handoverConfirmArmed = false;
      $('handOverBtn').classList.remove('danger');
      $('handOverBtn').textContent = 'Hand Over';

      if (amHost()) handOver();
      else broadcast('handover', {});  // active DJ (guest) can request; host executes
    };

    $('stillBtn').onclick     = ()=> amHost()? extendPeriod(msPerTrack()) : null;
    $('resetBtn').onclick     = ()=> amHost()? resetTurn() : null;
    $('removeActiveBtn').onclick = ()=>{
      if (!amHost()) return;
      const active=state.participants[state.active_index]; if (active) hostRemoveParticipant(active.id);
    };

    tracksSel.onchange = (e)=>{
      const v=parseInt(e.target.value||'1',10);
      if (!amHost()) { tracksSel.value=String(state.tracks_per_turn); return toast('Host only'); }
      state.tracks_per_turn=Math.max(1,Math.min(3,v));
      broadcast('tpt', { v: state.tracks_per_turn });
      renderAll(); sync();
    };
    minutesSel.onchange = (e)=>{
      const v=parseInt(e.target.value||'6',10);
      if (!amHost()) { minutesSel.value=String(state.minutes_per_track); return toast('Host only'); }
      state.minutes_per_track=Math.max(1,Math.min(60,v));
      setStillBtnLabel();
      if (state.phase==='idle'){ state.turn_total_ms=totalBudgetMs(); timerEl.textContent=fmt(state.turn_total_ms); renderProgress(); }
      broadcast('mpt', { v: state.minutes_per_track });
      renderAll(); sync();
    };

    // ----- Push (OneSignal) -----
    async function setupPush(){
      try {
        if (!('OneSignal' in window)) return;
        const res = await OneSignal.Notifications.requestPermission();
        if (res !== 'granted') return;
        const playerId = await OneSignal.User.getId();
        if (!playerId) return;
        await supabase.from('push_tokens').upsert({
          profile_local_id: me.id,
          onesignal_player_id: playerId,
          last_seen_at: new Date().toISOString()
        }, { onConflict: 'profile_local_id' });
      } catch(e){ console.warn('setupPush failed', e); }
    }
    async function notifyNextDJ(next){
      try{
        const { data } = await supabase.from('push_tokens')
          .select('onesignal_player_id').eq('profile_local_id', next.id).maybeSingle();
        const pid = data?.onesignal_player_id; if (!pid) return;
        await fetch(`${ENV.SUPABASE_URL.replace('.co','.co/functions/v1')}/send-turn-push`, {
          method:'POST', headers:{ 'Content-Type':'application/json' },
          body: JSON.stringify({
            playerId: pid,
            title: "You‚Äôre up next üéß",
            message: `${next.name||'DJ'} ‚Äî it‚Äôs your turn!`,
            url: `${ENV.BASE_URL}/s/${sessionId}`
          })
        });
      } catch(e){ console.warn('notifyNextDJ failed', e); }
    }

    // ----- Init -----
    (function init(){
      $('profileName').value = me.name || '';
      $('avatarPick').value  = me.avatar || 'ninja';
      $('colorPick').value   = me.color || '#7c3aed';
      tracksSel.value        = String(state.tracks_per_turn);
      minutesSel.value       = String(state.minutes_per_track);
      setStillBtnLabel();

      if (sessionId) { $('newSessionBtn').disabled = true; setupChannel(sessionId); }
      updateConnBadge();
      // setupPush(); // optional auto prompt
    })();
  </script>

  <!-- OneSignal SDK (push) -->
  <script src="https://cdn.onesignal.com/sdks/web/v16/OneSignalSDK.page.js" defer></script>
  <script>
    window.OneSignalDeferred = window.OneSignalDeferred || [];
    OneSignalDeferred.push(async function(OneSignal) {
      await OneSignal.init({ appId: "5060d504-c36b-4330-a408-b905427c79a0" });
    });
  </script>
</body>
</html>


